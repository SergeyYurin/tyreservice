{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst _1 = require(\".\");\n\nconst util_1 = require(\"./util\");\n\nconst google_gax_1 = require(\"google-gax\");\n\nconst reference_1 = require(\"./reference\");\n/**\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n *\n * @private\n */\n\n\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\n\nexports.MAX_PENDING_OPS = 5000;\n/**\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\n\nconst MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n */\n\nclass RecursiveDelete {\n  /**\n   *\n   * @param firestore The Firestore instance to use.\n   * @param writer The BulkWriter instance to use for delete operations.\n   * @param ref The document or collection reference to recursively delete.\n   */\n  constructor(firestore, writer, ref) {\n    this.firestore = firestore;\n    this.writer = writer;\n    this.ref = ref;\n    /**\n     * The number of deletes that failed with a permanent error.\n     * @private\n     */\n\n    this.errorCount = 0;\n    /**\n     * Whether there are still documents to delete that still need to be fetched.\n     * @private\n     */\n\n    this.documentsPending = true;\n    /**\n     * A deferred promise that resolves when the recursive delete operation\n     * is completed.\n     * @private\n     */\n\n    this.completionDeferred = new util_1.Deferred();\n    /**\n     * Whether a query stream is currently in progress. Only one stream can be\n     * run at a time.\n     * @private\n     */\n\n    this.streamInProgress = false;\n    /**\n     * The number of pending BulkWriter operations. Used to determine when the\n     * next query can be run.\n     * @private\n     */\n\n    this.pendingOpsCount = 0;\n    this.errorStack = '';\n  }\n  /**\n   * Recursively deletes the reference provided in the class constructor.\n   * Returns a promise that resolves when all descendants have been deleted, or\n   * if an error occurs.\n   */\n\n\n  run() {\n    assert(this.documentsPending, 'The recursive delete operation has already been completed.'); // Capture the error stack to preserve stack tracing across async calls.\n\n    this.errorStack = Error().stack;\n\n    this.writer._verifyNotClosed();\n\n    this.setupStream();\n    return this.completionDeferred.promise;\n  }\n  /**\n   * Creates a query stream and attaches event handlers to it.\n   * @private\n   */\n\n\n  setupStream() {\n    const limit = exports.MAX_PENDING_OPS;\n    const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference ? this.ref : this.ref, limit);\n    this.streamInProgress = true;\n    let streamedDocsCount = 0;\n    stream.on('error', err => {\n      err.code = google_gax_1.Status.UNAVAILABLE;\n      err.stack = 'Failed to fetch children documents: ' + err.stack;\n      this.lastError = err;\n      this.onQueryEnd();\n    }).on('data', snap => {\n      streamedDocsCount++;\n      this.lastDocumentSnap = snap;\n      this.deleteRef(snap.ref);\n    }).on('end', () => {\n      this.streamInProgress = false; // If there are fewer than the number of documents specified in the\n      // limit() field, we know that the query is complete.\n\n      if (streamedDocsCount < limit) {\n        this.onQueryEnd();\n      } else if (this.pendingOpsCount === 0) {\n        this.setupStream();\n      }\n    });\n  }\n  /**\n   * Retrieves all descendant documents nested under the provided reference.\n   * @param ref The reference to fetch all descendants for.\n   * @param limit The number of descendants to fetch in the query.\n   * @private\n   * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n   */\n\n\n  getAllDescendants(ref, limit) {\n    // The parent is the closest ancestor document to the location we're\n    // deleting. If we are deleting a document, the parent is the path of that\n    // document. If we are deleting a collection, the parent is the path of the\n    // document containing that collection (or the database root, if it is a\n    // root collection).\n    let parentPath = ref._resourcePath;\n\n    if (ref instanceof _1.CollectionReference) {\n      parentPath = parentPath.popLast();\n    }\n\n    const collectionId = ref instanceof _1.CollectionReference ? ref.id : ref.parent.id;\n    let query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId,\n    /* requireConsistency= */\n    false)); // Query for names only to fetch empty snapshots.\n\n    query = query.select(_1.FieldPath.documentId()).limit(limit);\n\n    if (ref instanceof _1.CollectionReference) {\n      // To find all descendants of a collection reference, we need to use a\n      // composite filter that captures all documents that start with the\n      // collection prefix. The MIN_KEY constant represents the minimum key in\n      // this collection, and a null byte + the MIN_KEY represents the minimum\n      // key is the next possible collection.\n      const nullChar = String.fromCharCode(0);\n      const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n      const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n      query = query.where(_1.FieldPath.documentId(), '>=', startAt).where(_1.FieldPath.documentId(), '<', endAt);\n    }\n\n    if (this.lastDocumentSnap) {\n      query = query.startAfter(this.lastDocumentSnap);\n    }\n\n    return query.stream();\n  }\n  /**\n   * Called when all descendants of the provided reference have been streamed\n   * or if a permanent error occurs during the stream. Deletes the developer\n   * provided reference and wraps any errors that occurred.\n   * @private\n   */\n\n\n  onQueryEnd() {\n    this.documentsPending = false;\n\n    if (this.ref instanceof _1.DocumentReference) {\n      this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\n    }\n\n    this.writer.flush().then(async () => {\n      var _a;\n\n      if (this.lastError === undefined) {\n        this.completionDeferred.resolve();\n      } else {\n        let error = new google_gax_1.GoogleError(`${this.errorCount} ` + `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` + 'failed. The last delete failed with: ');\n\n        if (this.lastError.code !== undefined) {\n          error.code = this.lastError.code;\n        }\n\n        error = util_1.wrapError(error, this.errorStack); // Wrap the BulkWriter error last to provide the full stack trace.\n\n        this.completionDeferred.reject(this.lastError.stack ? util_1.wrapError(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '') : error);\n      }\n    });\n  }\n  /**\n   * Deletes the provided reference and starts the next stream if conditions\n   * are met.\n   * @private\n   */\n\n\n  deleteRef(docRef) {\n    this.pendingOpsCount++;\n    this.writer.delete(docRef).catch(err => {\n      this.incrementErrorCount(err);\n    }).then(() => {\n      this.pendingOpsCount--; // We wait until the previous stream has ended in order to sure the\n      // startAfter document is correct. Starting the next stream while\n      // there are pending operations allows Firestore to maximize\n      // BulkWriter throughput.\n\n      if (this.documentsPending && !this.streamInProgress && this.pendingOpsCount < MIN_PENDING_OPS) {\n        this.setupStream();\n      }\n    });\n  }\n\n  incrementErrorCount(err) {\n    this.errorCount++;\n    this.lastError = err;\n  }\n\n}\n\nexports.RecursiveDelete = RecursiveDelete;","map":{"version":3,"sources":["/Users/compucter/node_modules/@google-cloud/firestore/build/src/recursive-delete.js"],"names":["Object","defineProperty","exports","value","assert","require","_1","util_1","google_gax_1","reference_1","REFERENCE_NAME_MIN_ID","MAX_PENDING_OPS","MIN_PENDING_OPS","RecursiveDelete","constructor","firestore","writer","ref","errorCount","documentsPending","completionDeferred","Deferred","streamInProgress","pendingOpsCount","errorStack","run","Error","stack","_verifyNotClosed","setupStream","promise","limit","stream","getAllDescendants","CollectionReference","streamedDocsCount","on","err","code","Status","UNAVAILABLE","lastError","onQueryEnd","snap","lastDocumentSnap","deleteRef","parentPath","_resourcePath","popLast","collectionId","id","parent","query","Query","QueryOptions","forKindlessAllDescendants","select","FieldPath","documentId","nullChar","String","fromCharCode","startAt","endAt","where","startAfter","DocumentReference","delete","catch","incrementErrorCount","flush","then","_a","undefined","resolve","error","GoogleError","wrapError","reject","docRef"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,GAAD,CAAlB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,YAAD,CAA5B;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,aAAD,CAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAH,OAAO,CAACQ,qBAAR,GAAgC,4BAAhC;AACA;AACA;AACA;AACA;AACA;AACA;;AACAR,OAAO,CAACS,eAAR,GAA0B,IAA1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,eAAe,GAAG,IAAxB;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,eAAN,CAAsB;AAClB;AACJ;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,SAAD,EAAYC,MAAZ,EAAoBC,GAApB,EAAyB;AAChC,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA;AACR;AACA;AACA;;AACQ,SAAKC,UAAL,GAAkB,CAAlB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,IAAxB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,kBAAL,GAA0B,IAAIb,MAAM,CAACc,QAAX,EAA1B;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,KAAxB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,GAAG,GAAG;AACFrB,IAAAA,MAAM,CAAC,KAAKe,gBAAN,EAAwB,4DAAxB,CAAN,CADE,CAEF;;AACA,SAAKK,UAAL,GAAkBE,KAAK,GAAGC,KAA1B;;AACA,SAAKX,MAAL,CAAYY,gBAAZ;;AACA,SAAKC,WAAL;AACA,WAAO,KAAKT,kBAAL,CAAwBU,OAA/B;AACH;AACD;AACJ;AACA;AACA;;;AACID,EAAAA,WAAW,GAAG;AACV,UAAME,KAAK,GAAG7B,OAAO,CAACS,eAAtB;AACA,UAAMqB,MAAM,GAAG,KAAKC,iBAAL,CAAuB,KAAKhB,GAAL,YAAoBX,EAAE,CAAC4B,mBAAvB,GAChC,KAAKjB,GAD2B,GAEhC,KAAKA,GAFI,EAECc,KAFD,CAAf;AAGA,SAAKT,gBAAL,GAAwB,IAAxB;AACA,QAAIa,iBAAiB,GAAG,CAAxB;AACAH,IAAAA,MAAM,CACDI,EADL,CACQ,OADR,EACiBC,GAAG,IAAI;AACpBA,MAAAA,GAAG,CAACC,IAAJ,GAAW9B,YAAY,CAAC+B,MAAb,CAAoBC,WAA/B;AACAH,MAAAA,GAAG,CAACV,KAAJ,GAAY,yCAAyCU,GAAG,CAACV,KAAzD;AACA,WAAKc,SAAL,GAAiBJ,GAAjB;AACA,WAAKK,UAAL;AACH,KAND,EAOKN,EAPL,CAOQ,MAPR,EAOiBO,IAAD,IAAU;AACtBR,MAAAA,iBAAiB;AACjB,WAAKS,gBAAL,GAAwBD,IAAxB;AACA,WAAKE,SAAL,CAAeF,IAAI,CAAC1B,GAApB;AACH,KAXD,EAYKmB,EAZL,CAYQ,KAZR,EAYe,MAAM;AACjB,WAAKd,gBAAL,GAAwB,KAAxB,CADiB,CAEjB;AACA;;AACA,UAAIa,iBAAiB,GAAGJ,KAAxB,EAA+B;AAC3B,aAAKW,UAAL;AACH,OAFD,MAGK,IAAI,KAAKnB,eAAL,KAAyB,CAA7B,EAAgC;AACjC,aAAKM,WAAL;AACH;AACJ,KAtBD;AAuBH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACII,EAAAA,iBAAiB,CAAChB,GAAD,EAAMc,KAAN,EAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,QAAIe,UAAU,GAAG7B,GAAG,CAAC8B,aAArB;;AACA,QAAI9B,GAAG,YAAYX,EAAE,CAAC4B,mBAAtB,EAA2C;AACvCY,MAAAA,UAAU,GAAGA,UAAU,CAACE,OAAX,EAAb;AACH;;AACD,UAAMC,YAAY,GAAGhC,GAAG,YAAYX,EAAE,CAAC4B,mBAAlB,GACfjB,GAAG,CAACiC,EADW,GAEfjC,GAAG,CAACkC,MAAJ,CAAWD,EAFjB;AAGA,QAAIE,KAAK,GAAG,IAAI9C,EAAE,CAAC+C,KAAP,CAAa,KAAKtC,SAAlB,EAA6BN,WAAW,CAAC6C,YAAZ,CAAyBC,yBAAzB,CAAmDT,UAAnD,EAA+DG,YAA/D;AACzC;AAA0B,SADe,CAA7B,CAAZ,CAb0B,CAe1B;;AACAG,IAAAA,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAalD,EAAE,CAACmD,SAAH,CAAaC,UAAb,EAAb,EAAwC3B,KAAxC,CAA8CA,KAA9C,CAAR;;AACA,QAAId,GAAG,YAAYX,EAAE,CAAC4B,mBAAtB,EAA2C;AACvC;AACA;AACA;AACA;AACA;AACA,YAAMyB,QAAQ,GAAGC,MAAM,CAACC,YAAP,CAAoB,CAApB,CAAjB;AACA,YAAMC,OAAO,GAAGb,YAAY,GAAG,GAAf,GAAqB/C,OAAO,CAACQ,qBAA7C;AACA,YAAMqD,KAAK,GAAGd,YAAY,GAAGU,QAAf,GAA0B,GAA1B,GAAgCzD,OAAO,CAACQ,qBAAtD;AACA0C,MAAAA,KAAK,GAAGA,KAAK,CACRY,KADG,CACG1D,EAAE,CAACmD,SAAH,CAAaC,UAAb,EADH,EAC8B,IAD9B,EACoCI,OADpC,EAEHE,KAFG,CAEG1D,EAAE,CAACmD,SAAH,CAAaC,UAAb,EAFH,EAE8B,GAF9B,EAEmCK,KAFnC,CAAR;AAGH;;AACD,QAAI,KAAKnB,gBAAT,EAA2B;AACvBQ,MAAAA,KAAK,GAAGA,KAAK,CAACa,UAAN,CAAiB,KAAKrB,gBAAtB,CAAR;AACH;;AACD,WAAOQ,KAAK,CAACpB,MAAN,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIU,EAAAA,UAAU,GAAG;AACT,SAAKvB,gBAAL,GAAwB,KAAxB;;AACA,QAAI,KAAKF,GAAL,YAAoBX,EAAE,CAAC4D,iBAA3B,EAA8C;AAC1C,WAAKlD,MAAL,CAAYmD,MAAZ,CAAmB,KAAKlD,GAAxB,EAA6BmD,KAA7B,CAAmC/B,GAAG,IAAI,KAAKgC,mBAAL,CAAyBhC,GAAzB,CAA1C;AACH;;AACD,SAAKrB,MAAL,CAAYsD,KAAZ,GAAoBC,IAApB,CAAyB,YAAY;AACjC,UAAIC,EAAJ;;AACA,UAAI,KAAK/B,SAAL,KAAmBgC,SAAvB,EAAkC;AAC9B,aAAKrD,kBAAL,CAAwBsD,OAAxB;AACH,OAFD,MAGK;AACD,YAAIC,KAAK,GAAG,IAAInE,YAAY,CAACoE,WAAjB,CAA8B,GAAE,KAAK1D,UAAW,GAAnB,GACpC,GAAE,KAAKA,UAAL,KAAoB,CAApB,GAAwB,SAAxB,GAAoC,QAAS,GADX,GAErC,uCAFQ,CAAZ;;AAGA,YAAI,KAAKuB,SAAL,CAAeH,IAAf,KAAwBmC,SAA5B,EAAuC;AACnCE,UAAAA,KAAK,CAACrC,IAAN,GAAa,KAAKG,SAAL,CAAeH,IAA5B;AACH;;AACDqC,QAAAA,KAAK,GAAGpE,MAAM,CAACsE,SAAP,CAAiBF,KAAjB,EAAwB,KAAKnD,UAA7B,CAAR,CAPC,CAQD;;AACA,aAAKJ,kBAAL,CAAwB0D,MAAxB,CAA+B,KAAKrC,SAAL,CAAed,KAAf,GACzBpB,MAAM,CAACsE,SAAP,CAAiBF,KAAjB,EAAwB,CAACH,EAAE,GAAG,KAAK/B,SAAL,CAAed,KAArB,MAAgC,IAAhC,IAAwC6C,EAAE,KAAK,KAAK,CAApD,GAAwDA,EAAxD,GAA6D,EAArF,CADyB,GAEzBG,KAFN;AAGH;AACJ,KAlBD;AAmBH;AACD;AACJ;AACA;AACA;AACA;;;AACI9B,EAAAA,SAAS,CAACkC,MAAD,EAAS;AACd,SAAKxD,eAAL;AACA,SAAKP,MAAL,CACKmD,MADL,CACYY,MADZ,EAEKX,KAFL,CAEW/B,GAAG,IAAI;AACd,WAAKgC,mBAAL,CAAyBhC,GAAzB;AACH,KAJD,EAKKkC,IALL,CAKU,MAAM;AACZ,WAAKhD,eAAL,GADY,CAEZ;AACA;AACA;AACA;;AACA,UAAI,KAAKJ,gBAAL,IACA,CAAC,KAAKG,gBADN,IAEA,KAAKC,eAAL,GAAuBX,eAF3B,EAE4C;AACxC,aAAKiB,WAAL;AACH;AACJ,KAhBD;AAiBH;;AACDwC,EAAAA,mBAAmB,CAAChC,GAAD,EAAM;AACrB,SAAKnB,UAAL;AACA,SAAKuB,SAAL,GAAiBJ,GAAjB;AACH;;AA9LiB;;AAgMtBnC,OAAO,CAACW,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst _1 = require(\".\");\nconst util_1 = require(\"./util\");\nconst google_gax_1 = require(\"google-gax\");\nconst reference_1 = require(\"./reference\");\n/**\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n *\n * @private\n */\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\nexports.MAX_PENDING_OPS = 5000;\n/**\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\nconst MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n */\nclass RecursiveDelete {\n    /**\n     *\n     * @param firestore The Firestore instance to use.\n     * @param writer The BulkWriter instance to use for delete operations.\n     * @param ref The document or collection reference to recursively delete.\n     */\n    constructor(firestore, writer, ref) {\n        this.firestore = firestore;\n        this.writer = writer;\n        this.ref = ref;\n        /**\n         * The number of deletes that failed with a permanent error.\n         * @private\n         */\n        this.errorCount = 0;\n        /**\n         * Whether there are still documents to delete that still need to be fetched.\n         * @private\n         */\n        this.documentsPending = true;\n        /**\n         * A deferred promise that resolves when the recursive delete operation\n         * is completed.\n         * @private\n         */\n        this.completionDeferred = new util_1.Deferred();\n        /**\n         * Whether a query stream is currently in progress. Only one stream can be\n         * run at a time.\n         * @private\n         */\n        this.streamInProgress = false;\n        /**\n         * The number of pending BulkWriter operations. Used to determine when the\n         * next query can be run.\n         * @private\n         */\n        this.pendingOpsCount = 0;\n        this.errorStack = '';\n    }\n    /**\n     * Recursively deletes the reference provided in the class constructor.\n     * Returns a promise that resolves when all descendants have been deleted, or\n     * if an error occurs.\n     */\n    run() {\n        assert(this.documentsPending, 'The recursive delete operation has already been completed.');\n        // Capture the error stack to preserve stack tracing across async calls.\n        this.errorStack = Error().stack;\n        this.writer._verifyNotClosed();\n        this.setupStream();\n        return this.completionDeferred.promise;\n    }\n    /**\n     * Creates a query stream and attaches event handlers to it.\n     * @private\n     */\n    setupStream() {\n        const limit = exports.MAX_PENDING_OPS;\n        const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference\n            ? this.ref\n            : this.ref, limit);\n        this.streamInProgress = true;\n        let streamedDocsCount = 0;\n        stream\n            .on('error', err => {\n            err.code = google_gax_1.Status.UNAVAILABLE;\n            err.stack = 'Failed to fetch children documents: ' + err.stack;\n            this.lastError = err;\n            this.onQueryEnd();\n        })\n            .on('data', (snap) => {\n            streamedDocsCount++;\n            this.lastDocumentSnap = snap;\n            this.deleteRef(snap.ref);\n        })\n            .on('end', () => {\n            this.streamInProgress = false;\n            // If there are fewer than the number of documents specified in the\n            // limit() field, we know that the query is complete.\n            if (streamedDocsCount < limit) {\n                this.onQueryEnd();\n            }\n            else if (this.pendingOpsCount === 0) {\n                this.setupStream();\n            }\n        });\n    }\n    /**\n     * Retrieves all descendant documents nested under the provided reference.\n     * @param ref The reference to fetch all descendants for.\n     * @param limit The number of descendants to fetch in the query.\n     * @private\n     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n     */\n    getAllDescendants(ref, limit) {\n        // The parent is the closest ancestor document to the location we're\n        // deleting. If we are deleting a document, the parent is the path of that\n        // document. If we are deleting a collection, the parent is the path of the\n        // document containing that collection (or the database root, if it is a\n        // root collection).\n        let parentPath = ref._resourcePath;\n        if (ref instanceof _1.CollectionReference) {\n            parentPath = parentPath.popLast();\n        }\n        const collectionId = ref instanceof _1.CollectionReference\n            ? ref.id\n            : ref.parent.id;\n        let query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, \n        /* requireConsistency= */ false));\n        // Query for names only to fetch empty snapshots.\n        query = query.select(_1.FieldPath.documentId()).limit(limit);\n        if (ref instanceof _1.CollectionReference) {\n            // To find all descendants of a collection reference, we need to use a\n            // composite filter that captures all documents that start with the\n            // collection prefix. The MIN_KEY constant represents the minimum key in\n            // this collection, and a null byte + the MIN_KEY represents the minimum\n            // key is the next possible collection.\n            const nullChar = String.fromCharCode(0);\n            const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n            const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n            query = query\n                .where(_1.FieldPath.documentId(), '>=', startAt)\n                .where(_1.FieldPath.documentId(), '<', endAt);\n        }\n        if (this.lastDocumentSnap) {\n            query = query.startAfter(this.lastDocumentSnap);\n        }\n        return query.stream();\n    }\n    /**\n     * Called when all descendants of the provided reference have been streamed\n     * or if a permanent error occurs during the stream. Deletes the developer\n     * provided reference and wraps any errors that occurred.\n     * @private\n     */\n    onQueryEnd() {\n        this.documentsPending = false;\n        if (this.ref instanceof _1.DocumentReference) {\n            this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\n        }\n        this.writer.flush().then(async () => {\n            var _a;\n            if (this.lastError === undefined) {\n                this.completionDeferred.resolve();\n            }\n            else {\n                let error = new google_gax_1.GoogleError(`${this.errorCount} ` +\n                    `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` +\n                    'failed. The last delete failed with: ');\n                if (this.lastError.code !== undefined) {\n                    error.code = this.lastError.code;\n                }\n                error = util_1.wrapError(error, this.errorStack);\n                // Wrap the BulkWriter error last to provide the full stack trace.\n                this.completionDeferred.reject(this.lastError.stack\n                    ? util_1.wrapError(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '')\n                    : error);\n            }\n        });\n    }\n    /**\n     * Deletes the provided reference and starts the next stream if conditions\n     * are met.\n     * @private\n     */\n    deleteRef(docRef) {\n        this.pendingOpsCount++;\n        this.writer\n            .delete(docRef)\n            .catch(err => {\n            this.incrementErrorCount(err);\n        })\n            .then(() => {\n            this.pendingOpsCount--;\n            // We wait until the previous stream has ended in order to sure the\n            // startAfter document is correct. Starting the next stream while\n            // there are pending operations allows Firestore to maximize\n            // BulkWriter throughput.\n            if (this.documentsPending &&\n                !this.streamInProgress &&\n                this.pendingOpsCount < MIN_PENDING_OPS) {\n                this.setupStream();\n            }\n        });\n    }\n    incrementErrorCount(err) {\n        this.errorCount++;\n        this.lastError = err;\n    }\n}\nexports.RecursiveDelete = RecursiveDelete;\n//# sourceMappingURL=recursive-delete.js.map"]},"metadata":{},"sourceType":"script"}